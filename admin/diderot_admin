#!/usr/bin/env python3

'''
Initial script written by William Paivine (bill@paivine.com).

Updated/Maintined by Rohan Yadav (rohany@alumni.cmu.edu)

Admin version of the Diderot CLI, containing some extra
commands for instructors / TAs.
'''

import sys
import argparse

from inspect import getsourcefile
import os.path

current_path = os.path.abspath(getsourcefile(lambda:0))
current_dir = os.path.dirname(current_path)
parent_dir = current_dir[:current_dir.rfind(os.path.sep)]

sys.path.insert(0, parent_dir)

from diderot_core import DiderotCLI


class DiderotAdminCLI(DiderotCLI):

    # Hook for updating parts of assignments. For now, we only
    # aim to support changing the autograder/autograder-Makefile/handout/writeup
    # and punt finer grained changes to the UI.
    def do_update_assignment(self, line):
        args = self.parse_update_assignment(line)
        if args is None:
            return
        if self.api_client.update_assignment(args.course, args.homework, args):
            print("Success uploading files.")
        else:
            print("Uploading files failed. Try using the Web UI.")

    def parse_update_assignment(self, args):
        parser = self.create_course_parser("update_assignment")
        parser.add_argument('homework', type=str)
        parser.add_argument('--autograde-tar', type=str)
        parser.add_argument('--autograde-makefile', type=str)
        parser.add_argument('--writeup', type=str)
        parser.add_argument('--handout', type=str)
        try:
            return self.fix_course_args(parser.parse_args(args.split()))
        except SystemExit:
            return None

    def help_update_assignment(self):
        self.parse_update_assignment("update_assignment -h")


    def do_list_books(self, line):
        args = self.parse_list_books(line)
        if args is None:
            return
        res = self.api_client.list_books(args.course)
        if res is None:
            print("Error listing books.")
        else:
            print("\t".join([c['label'] for c in res]))

    def parse_list_books(self, args):
        parser = argparse.ArgumentParser(prog="list_books", description="List all books, specify course if desired.")
        parser.add_argument('--course', type=str, default=None)
        try:
            return parser.parse_args(args.split())
        except SystemExit:
            return None

    def help_list_books(self):
        self.parse_list_books("list_books -h")

    def do_list_parts(self, line):
        args = self.parse_list_parts(line)
        if args is None:
            return
        res = self.api_client.list_parts(args.course, args.book)
        if res is None:
            print("Error listing parts.")
        else:
            print("\n".join(["{}. {}".format(c['rank'], c['title']) for c in res]))

    def parse_list_parts(self, args):
        parser = self.create_course_parser("list_parts")
        parser.add_argument("book", help="Book label")
        try:
            return self.fix_course_args(parser.parse_args(args.split()))
        except SystemExit:
            return None

    def help_list_parts(self):
        self.parse_list_parts("list_parts -h")


    # TODO (rohany): optionally constrain this lookup by part
    def do_list_chapters(self, line):
        args = self.parse_list_chapters(line)
        if args is None:
            return
        res = self.api_client.list_chapters(args.course, args.book)
        if res is None:
            print("Error listing books.")
        else:
            # TODO (rohany): use some fancy terminal printing for this output.
            print("\n".join(["{}. {}".format(str(float(c['rank'])).rstrip('0').rstrip('.'), c['title']) for c in res]))

    def parse_list_chapters(self, args):
        parser = self.create_course_parser("list_chapters")
        parser.add_argument("book", help="Book label")
        try:
            return self.fix_course_args(parser.parse_args(args.split()))
        except SystemExit:
            return None

    def help_list_chapters(self):
        self.parse_list_chapters("list_chapters -h")


    def do_create_chapter(self, line):
        args = self.parse_create_chapter(line)
        if args.title is not None:
            args.title = " ".join(args.title)
        if args is None:
            return
        if self.api_client.create_chapter(args):
            print("Successfully created chapter.")
        else:
            print("Chapter creation failed.")

    def parse_create_chapter(self, args):
        parser = self.create_course_parser("create_chapter")
        parser.add_argument("book", help="Book label")
        parser.add_argument("--part", help="Part number", required=True)
        parser.add_argument("--number", help="New chapter number", required=True)
        parser.add_argument("--title", help="Optional chapter title (default = Chapter). To have a multi-word title, do not use quotes. For example, if the title 'My Chapter' is desired, invoke using '--title My Chapter'", default=None, nargs='+')
        parser.add_argument("--label", help="Optional chapter label (default = randomly generated)", default=None)
        try:
            return self.fix_course_args(parser.parse_args(args.split()))
        except SystemExit:
            return None

    def help_create_chapter(self):
        self.parse_create_chapter("create_chapter -h")


    def do_upload_chapter(self, line):
        args = self.parse_upload_chapter(line)
        if args is None:
            return
        if not self.verify_upload_chapter_args(args):
            return
        success = self.api_client.upload_chapter(args.course, args.book, args.chapter, args)
        if not success:
            print("Failure uploading chapter.")
        else:
            print("Book uploaded successfully.")

    def verify_upload_chapter_args(self, args):
        if args.video_url is not None and not (args.slides is None or args.pdf is None):
            print("Cannot use --video_url if not uploading slides.")
            return False
        if args.images is not None and args.xml is None:
            print("Cannot use --images if not uploading xml/mlx.")
            return False
        return True


    def parse_upload_chapter(self, args):
        parser = self.create_course_parser("upload_chapter")
        parser.add_argument("book", type=str, help="target book label")
        parser.add_argument("chapter", type=str, help="target chapter number")
        file_group = parser.add_mutually_exclusive_group(required=True)

        # We can upload PDF's.
        file_group.add_argument('--pdf', type=str, default=None, help="upload a pdf")

        # We can upload slides.
        file_group.add_argument('--slides', type=str, default=None, help="upload slides")
        # If the user sends slides, we also allow sending a video URL with the slides.
        parser.add_argument('--video_url', type=str, default=None, help="upload an embeddable video url")

        # We can upload XML.
        file_group.add_argument('--xml', type=str, default=None, help="upload an xml/mlx document")
        # When uploading XML, the user can pass in a list of images that need
        # to be uploaded along side the xml.
        parser.add_argument('--attach', type=str, nargs='+', default=None, help="upload a list of attachments for the xml/mlx document")
        # When uploading XML, the user can also pass in a PDF version of the XML
        # for easy downloading.
        parser.add_argument('--xml_pdf', type=str, default=None, help="PDF version of the XML document")
        try:
            return self.fix_course_args(parser.parse_args(args.split()))
        except SystemExit:
            return None

    def help_upload_chapter(self):
        self.parse_upload_chapter("upload_chapter -h")


if __name__ == '__main__':
    if len(sys.argv) > 1:
        # TODO: get rid of this ability from the student accessible version.
        DiderotAdminCLI().cmdloop(sys.argv[1])
    else:
        DiderotAdminCLI().cmdloop("https://www.diderot.one")
